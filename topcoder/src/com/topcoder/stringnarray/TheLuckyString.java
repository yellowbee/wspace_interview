package com.topcoder.stringnarray;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

/*
 * Problem Statement
    	John and Brus are studying string theory at the university. According to Brus, a string is called lucky if no two consecutive characters are equal. John is analyzing a String s, and he wants to know how many distinct lucky strings can be generated by reordering the letters in s. If s is a lucky string in its original ordering, it should also be considered in the count.
 
Definition
    	
Class:	TheLuckyString
Method:	count
Parameters:	String
Returns:	int
Method signature:	int count(String s)
(be sure your method is public)
    
 
Constraints
-	s will contain between 1 and 10 characters, inclusive.
-	Each character of s will be a lowercase letter ('a' - 'z').
 
Examples
0)	
    	
"ab"
Returns: 2
Two lucky strings - "ab" and "ba".
1)	
    	
"aaab"
Returns: 0
It's impossible to construct a lucky string.
2)	
    	
"aabbbaa"
Returns: 1
"abababa" is the only lucky string that can be generated.
3)	
    	
"abcdefghij"
Returns: 3628800

 */

public class TheLuckyString {
	public static void main(String[] args) {
		TheLuckyString ls = new TheLuckyString();
		System.out.println(ls.count("abcdefghij"));
	}
	
	public int count(String s) {
		Set<String> set = new HashSet<String>();
		StringBuffer sofar = new StringBuffer();
		boolean[] visited = new boolean[s.length()];
		Arrays.fill(visited, false);
		reorderString(s, sofar, set, visited);
		
		//System.out.println(set);
		int count = 0;
		for (String str : set) {
			for (int i=1; i<str.length(); i++) {
				boolean isLucky = true;
				if (str.charAt(i) == str.charAt(i-1)) {
					isLucky = false;
					break;
				}
			}
			count++;
		}
		
		return count;
	}

	// recursive function to get all reordering of a string
	// and save it in the set
	public void reorderString(String s, StringBuffer sofar, Set<String> set, boolean[] visited) {
		for (int i=0; i<s.length(); i++) {
			if (!visited[i]) {
				sofar.append(s.charAt(i));
				if (sofar.length() == s.length()) {
					String newString = new String(sofar);
					if (!set.contains(newString)) {
						set.add(newString);
					}
				}
				else {
					visited[i] = true;
					reorderString(s, sofar, set, visited);
					visited[i] = false;
				}
				sofar.deleteCharAt(sofar.length()-1);
			}
		}
	}
}
